const std = @import("std");

// consider:
// instead of
// percent () percent {}
// use
// fn () {
//   avail percent ( ... variables to make available ) {
// or capturing ie
//  precent ( ... variables to make available ) []

const ui = struct {
    const Component = struct {
        data: usize,
        method: *const fn(a: usize) void,
        fn render(component: Component) void {
            return component.method(component.data);
        }
    };

    fn callback(src: std.builtin.SourceLocation, sval: anytype, comptime fnval: fn( @TypeOf(sval) ) void) Component {
        _ = src;
        const SvalTy = @TypeOf(sval);
        const method = struct{ fn a(b: usize) void {
            return fnval( @as(*const SvalTy, @ptrFromInt(b)).* );
        }}.a;
        return Component{
            .data = @intFromPtr(sval),
            .method = &method,
        };
    }
};

fn evaluate %( %.child: ui.Component %) void %{
    %.child.render();
%}

fn Sample %( %.name: []const u8 %) usize %{
    %._usr = 6;
    evaluate(%[
        %._usr += %.name.len;
    %]);
    return %._usr;
%}

test "zix" {
    try std.testing.expectEqual(@as(usize, 10), Sample("test"));
}
